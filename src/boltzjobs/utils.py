"""module for various utility functions and classes"""

from __future__ import annotations

import json
from itertools import product
from typing import Any, Generator

import yaml


class FlowStyleList(list):
    """A custom list class to represent lists in YAML's flow style."""

    pass


class SingleQuoted(str):
    """A custom string class to represent strings in YAML with single quotes."""

    pass


class IndentedDumper(yaml.SafeDumper):
    """A custom dumper to force indentation on list items."""

    def increase_indent(self, flow: bool = False, indentless: bool = False) -> None:
        # return super(IndentedDumper, self).increase_indent(flow, False)
        return super().increase_indent(flow, False)


def flow_style_list_representer(dumper: yaml.SafeDumper, data: Any):
    """Represents a Python list in YAML's flow style (e.g., [A, B, C])."""
    return dumper.represent_sequence("tag:yaml.org,2002:seq", data, flow_style=True)


def single_quoted_representer(dumper: yaml.SafeDumper, data: Any):
    """Represents a string in YAML with single quotes."""
    return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="'")


# Register the custom representers with the IndentedDumper
IndentedDumper.add_representer(FlowStyleList, flow_style_list_representer)
IndentedDumper.add_representer(SingleQuoted, single_quoted_representer)


def chain_id(letters: str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ") -> Generator[str, None, None]:
    """
    Generator function to yield mmCIF chain IDs.

    This generator sequentially produces unique chain identifiers commonly used in mmCIF files.
    It generates all uppercase single-letter IDs ('A', 'B', ..., 'Z') followed by all possible
    two-letter combinations in 'reverse spreadsheet style' ('AA', 'BA', ..., 'ZZ').

    Yields:
        str: A unique chain ID in the sequence described.
    """
    # Yield single uppercase letters first
    yield from letters

    # Yield combinations of two uppercase letters
    for combination in product(letters, repeat=2):
        yield "".join(reversed(combination))

    return


def get_msa_from_json(
    json_file: str, sequence: str, paired: bool = False
) -> str | None:
    """
    Read a JSON file generated by AF3 (<job_name>_data.json) and return the
    multiple sequence alignment (MSA) for the protein/RNA chain with
    the specified sequence.
    Default is to return the unpaired MSA, but the paired MSA can be returned for proteins.
    """
    with open(json_file, "r") as f:
        data = json.load(f)

    for entry in data["sequences"]:
        if chain := entry.get("protein"):
            if chain["sequence"] == sequence:
                msa: str = chain["unpairedMsa"] if not paired else chain["pairedMsa"]
                return msa
        if chain := entry.get("rna"):
            if chain["sequence"] == sequence:
                msa = chain["unpairedMsa"]
                return msa

    return None


def get_templates_from_json(json_file: str, sequence: str) -> list[Any] | None:
    """
    Read a JSON file generated by AF3 (<job_name>_data.json) and return the
    list of templates used for modeling the protein chain with
    the specified sequence.
    """
    with open(json_file, "r") as f:
        data = json.load(f)

    for entry in data["sequences"]:
        if chain := entry.get("protein"):
            if chain["sequence"] == sequence:
                templates: list[Any] = chain["templates"]
                return templates

    return None


def fasta_sequences(fasta_file: str) -> Generator[tuple[str, str], None, None]:
    """
    Read a FASTA formatted file and yield tuples with the title and the sequence
    """
    with open(fasta_file, "r") as f:
        title = ""
        sequence = ""
        for line in f:
            if line.startswith(">"):
                if title:
                    yield title, sequence
                title = line.strip()
                sequence = ""
            else:
                sequence += line.strip()
        yield title, sequence
